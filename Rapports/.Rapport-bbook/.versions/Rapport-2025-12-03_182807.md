# Rapport Projet Julia

Ornella Jana  Matteo Anna

## Introduction (ornella)

Dans le cadre de notre projet julia nous avons déterminé comme objectif de base la classification d’images. Nous voulions créer notre propre méthode de classification en utilisant les réseaux de neurones (CNN) mais par manque de temps nous avons décidé de faire plusieurs exercices, par exemple de la métaprogramation, du multipledispaching, et de la classification (package Flux et par lux) dont le centre était une classification des animaux (cheetah, tigre, hyene et jaguar). Pour avoir une représentation graphique de ce que nous faisions, nous avons décidé de créer une application interactive sous R (Rshiny) et sous Julia (Bonito).  

## Le dataset : (qui veut, Matteo ?)

```julia (editor=true, logging=false, output=true)

```
## La classification Lux (Jana)

```julia (editor=true, logging=false, output=true)

```
## Load (Anna)

```julia (editor=true, logging=false, output=true)

```
## Metaprogrammation (Jana)

```julia (editor=true, logging=false, output=true)

```
## Bonito (Ornella)

```julia (editor=true, logging=false, output=true)
import WGLMakie
import Makie
using ImageClassification

base_path = "/Users/admin/Desktop/MIASHS/MasterM1SSD/CoursRJulia/GitHub_package/ImageClassification.jl/data"

train_images, train_labels = load_dataset(dataset="train", size = (600,600))
val_images, val_labels  = load_dataset(dataset="validation", size = (600,600))

println("Train set: $(length(train_images)) images")
println("Validation set: $(length(val_images)) images")

# Aprés l'importation des images on va faire notre interface graphique 
WGLMakie.activate!()
function interface_images(images)
    
    fig = Makie.Figure(size = (600, 600))

    ax = Makie.Axis(fig[1, 1], aspect = Makie.DataAspect())  # Taille NORMALISÉE

    Makie.hidexdecorations!(ax)
    Makie.hideydecorations!(ax)

    # Observable index
    current_index = Makie.Observable(1)

    # Correction orientation : WGLMakie inverse l'axe vertical.
    fix_orientation(img) = Makie.rotr90(img, 1)

    # Image affichée
    image_obs = Makie.Observable( fix_orientation(images[1]) )
    Makie.image!(ax, image_obs)

    # Mise à jour quand l’index change
    Makie.on(current_index) do idx
        image_obs[] = fix_orientation(images[idx])
    end

  # pour le bouton précédent
    btn_prev = Makie.Button(fig[2, 1], label = " Précédent")
    Makie.on(btn_prev.clicks) do _
        current_index[] = max(1, current_index[] - 1)
        println("Image précédente -> index : ", current_index[])
    end
    #on fait du mackie mais c'est okay car on peut tout de même 

    # pour le bouton suivant
    btn_next = Makie.Button(fig[2, 2], label = "Suivant ")
    Makie.on(btn_next.clicks) do _
        current_index[] = min(length(images), current_index[] + 1)
        println("Image suivante -> index : ", current_index[])
    end

    slider = Makie.Slider(fig[3, 1:2], range = 1:length(images), startvalue = 1)
    updating = Makie.Observable(false)
       # Slider -> index
Makie.on(slider.value) do v
    #c'est une boucle qui nous permet de faire une image puis de regarder la suivante
    if !updating[]
        updating[] = true
        current_index[] = Int(v)
        updating[] = false
    end
end

# Index -> slider
Makie.on(current_index) do idx
    if !updating[]
        updating[] = true
        slider.value[] = idx
        updating[] = false
    end
end
 
    Makie.display(fig)
end

interface_images(train_images)
#Warning: detected a stack overflow; program state may be corrupted, so further execution might be unreliable
```
## R (Ornella)

Pour la partie Rshiny j’ai décidé de créer une application interactive qui nous permet de visualiser, organiser et  de classer les images de notre base de données dans différentes catégories (par exemple, “Tigre”, “Hyène”, “Cheetah”, et on peut créer de nouvelles catégories si besoin). Je me suis d’abord formé au Rshiny avant de commencer à travailler la dessus. Ce qui m’a pris du temps pour pouvoir comprendre les grandes lignes.  Pour la suite, à chaque fois que j’avais besoin de créer quelque chose de spécifique j’allais chercher dans la bibliothèque des packages de Rshiny.  Puis j’ai fait une leçon sur posit (la bibio) https://shiny.posit.co/r/getstarted/shiny-basics/lesson1/ Ce qui m’a bien plus aidée que de regarder des tutos sur youtube. 

Je suis ensuite aller chercher sur posit un exemple de Rshniny classification, https://shiny.posit.co/r/gallery/life-sciences/biodiversity-national-parks/

Donc l’interface que j’ai créé est une application qui va permettre de sélectionner un dossier d’images depuis l’ordinateur de l’utilisateur, et d’afficher les images contenues dans ce dossier. Après avoir réussi il faut qu’on puisse naviguer simplement avec des flèches précédents et suivant, en faisant une boucle itérative. Pour garder cet aspect de classification j’aimerais pouvoir rajouter chaque image dans un dossier, et avoir la possibilité de créer de nouveaux dossiers, puis de pouvoir télécharger tous ces dossiers sur mon ordinateur.  Pour ce projet j’ai utiliser principalement les packages, shiny (framework permettant de créer des applications web interactives en R), shinydashboard (extension facilitant la mise en page sous forme de tableau de bord (“dashboard”)), shinyFiles (bibliothèque permettant à l’utilisateur de naviguer dans le système de fichiers local) et mime (pour détecter le type de fichier (JPEG, PNG, GIF, etc.) avant affichage) Quand je me suis formé j’ai vu qu’un Rshiny se divise en deux fichiers, ou alors en un seul fichier avec plusieurs parties, j’ai décidé d’utiliser les deux dossiers mais pour simplifier les manipulations lorsque je code.  Le fichier sera donc écrit comme ça :  ui <- dashboardPage(...)   # Interface utilisateur server <- function(...)    # Logique du serveur shinyApp(ui, server)    # Lancement de l'application Je vais décrire dans les prochaines parties comment j’ai coder et comment j’ai réfléchi. 

### a. Partie UI (User Interface)

Pour la partie interface je me suis basé sur un projet déjà existant, qui était donné dans la doc de Rshiny. Cette partie gère tout l’aspect visuel et interactif de l’application .Elle est construite avec dashboardPage() et il y a un en-tête (header) : qui affiche le titre de l’application étant “Classification d’images”. Une barre latérale (sidebar) qui contient le logo et les liens de l’Université Grenoble Alpes et il y a un menu de navigation avec deux onglets le “Home” pour la classification d’images et “ À propos de notre projet “ où il y aura la description du travail réalisé (je voulais m'entraîner à créer un menu de navigation).

### b. Partie Server

La partie serveur va gèrer : la sélection du dossier avec shinyDirChoose(). Mais aussi la lecture et le filtrage des images présentes dans le dossier choisi. Pour les boutons “Précédent” et “Suivant”, on va utiliser une logique de boucle pour les boutons. 

observeEvent(input:suivant, {     req(images())     idx = index() + 1     #on fait une boucle     if(idx > length(images())){       idx = 1       }  # boucle qui bouge vers la droite donc la fin du dossier (length(images))     index(idx)     updateSelectInput(session, "image", selected = basename(images())[idx])   })

J’ai ensuite créé des conditions qui me permettent de savoir si un dossier est déjà créé et sinon on peut le rajouter à notre liste de dossier, et tout ça va être créé directement sur l'ordinateur de l’utilisateur.  Chaque action sur ces boutons met à jour automatiquement le menu déroulant pour avoir l’image qui est actuellement affichée.C’est pour ça que pour chaque ajout d’images dans les dossiers de classification il va y avoir une notifications visuelles pour confirmer l’action.  L’affichage des images est également géré par le serveur, qui détecte automatiquement le type de fichier à l’aide du package mime afin de garantir que chaque image est correctement rendue dans l’interface. Enfin, toutes les interactions sont réactives, ce qui signifie que toute modification, qu’il s’agisse de la sélection d’une nouvelle image, de la création d’un dossier ou de l’ajout d’une image, est immédiatement reflétée dans l’interface utilisateur, offrant ainsi une expérience fluide et intuitive pour la classification des images.

## MD, animals (Anna)

```julia (editor=true, logging=false, output=true)

```
## MD, interactions (Anna)

```julia (editor=true, logging=false, output=true)

```
## MD, operateurs (Anna)

```julia (editor=true, logging=false, output=true)

```
## random sample (Anna)

```julia (editor=true, logging=false, output=true)

```
## type creation (Matteo)

```julia (editor=true, logging=false, output=true)

```
## Tests (Anna)

```julia (editor=true, logging=false, output=true)

```
